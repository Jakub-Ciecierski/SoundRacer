package pl.dybisz.testgry.shapes.complex;

import pl.dybisz.testgry.util.mathematics.Vector3;

/**
 * Class represents objects concerning player's movement,
 * road he is traveling and obstacles to omit.
 * <p></p>
 * In addition it holds all constants for each object type,
 * schedules rendering process and adapts scene to animation
 * changes in time.
 * <p></p>
 * Created by dybisz on 2014-12-01.
 */
public class GameBoard {
    /**
     * Tells {@link #render(float[]) render method} whether draw
     * {@link #road road} or not.
     */
    private static final boolean ROAD_RENDERING = true;
    /**
     * Represents a need for animation of the {@link #road}or not.
     * See {@link #switchFrame()} method's body.
     */
    private static final boolean ROAD_ANIMATION = true;
    /**
     * Tells {@link #render(float[]) render method} whether draw
     * obstacles objects produced {@link #obstaclesWorkshop obstacle workshop}
     * or not.
     */
    private static final boolean OBSTACLES_WORKSHOP_RENDERING = true;
    /**
     * Represents a need for animation of the {@link #obstaclesWorkshop} or not.
     * See {@link #switchFrame()} method's body.
     */
    private static final boolean OBSTACLES_WORKSHOP_ANIMATION = true;
    /**
     * Tells {@link #render(float[]) render method} whether draw
     * {@link #lattice lattice} or not.
     */
    private static final boolean LATTICE_RENDERING = false;
    /**
     * Represents a need for animation of the {@link #lattice} or not.
     * See {@link #switchFrame()} method's body.
     */
    private static final boolean LATTICE_ANIMATION = false;
    /**
     * Tells when to call {@link #switchFrame()} method to
     * proceed with animation.
     * Bigger this constant slower the animation of objects.
     */
    private static final float ANIMATION_FREQUENCY = 3.0f;
    /**
     * Specifies width of the generated road.
     */
    private static final float ROAD_WIDTH = 20.0f;
    /**
     * Color of t{@link #road road} in RGBA format.
     */
    private static float[] ROAD_COLOR = new float[]{0.5f, 0.5f, 0.5f, 0.8f};
    /**
     * Number of vertices used for GL_STRIPS to generate road.
     * More vertices  and lower {@link #TIME_UNIT_LENGTH}, higher the accuracy.
     * Also with {@link #TIME_UNIT_LENGTH} sets {@link #road} length.
     */
    private static final int ROAD_VERTICES_PER_BORDER = 100;
    /**
     * Very important constant. It tells how far should
     * object move at each animation step.
     * Bigger the number, bigger "steps" of the animation.
     * E.g. sinus function with this constant = 1, will be more
     * flat than with constant = 0.5;
     * <p></p>
     * Can also be interpreted as space "between two vertices" of the road border.
     */
    public static final float TIME_UNIT_LENGTH = 1f;
    /**
     * To save memory, class generates finite amount of obstacle
     * objects and then rearrange them on the scene using transformation
     * matrices.
     */
    public static final int NUMBER_OF_OBSTACLES = 16;
    /**
     * Color of whole lattice in RGBA format.
     */
    public static final float[] LATTICE_COLOR = new float[]{0.5f, 0.5f, 0.5f, 0.5f};
    /**
     * Width of the {@link #lattice}. Should be equal to {@link #ROAD_WIDTH}.
     */
    public static final float LATTICE_WIDTH = 20.0f;
    /**
     * Length of the {@link #lattice}. Should be equal to {@link #ROAD_VERTICES_PER_BORDER}
     * times {@link #TIME_UNIT_LENGTH}.
     */
    public static final float LATTICE_LENGTH = 100.f;
    /**
     * States what are the coordinates of the bottom right corner of the lattice.
     */
    public static final Vector3 LATTICE_BOTTOM_RIGHT_CORNER = new Vector3(0.0f, 0.0f, 0.0f);
    /**
     * We assume that lattice consists of squares and this constant tells how long
     * is the side of each of them.
     */
    public static final float LATTICE_GAP_LENGTH = 2.0f;
    /**
     * Specifies color of each obstacle generated by
     * {@link pl.dybisz.testgry.shapes.complex.ObstaclesWorkshop}.
     */
    public static final float[] OBSTACLES_COLOR = new float[]{0.1f,0.2f,0.3f,1.0f};
    /**
     * Obviously not every frame of the animation will produce new obstacle on the road,
     * so we need to specify kind of delay to this process.
     */
    public static final float OBSTACLE_GENERATION_TIME = 20;
    /**
     * Encapsulation of all methods concerning road.
     * See {@link pl.dybisz.testgry.shapes.complex.Road Road class}
     * for more details.
     */
    private Road road;
    /**
     * Encapsulation of all methods concerning road.
     * See {@link pl.dybisz.testgry.shapes.complex.ObstaclesWorkshop ObstacleWorkshop class}
     * for more details.
     */
    private ObstaclesWorkshop obstaclesWorkshop;
    /**
     * Encapsulation of all methods concerning road.
     * See {@link pl.dybisz.testgry.shapes.complex.Lattice Lattice class}
     * for more details.
     */
    private Lattice lattice;
    /**
     * Counts to next animation frame switch.
     */
    public static int animationCounter = 1;
    public static int tempCounter =1;

    public GameBoard() {
        // do poprawki road
        road = new Road(ROAD_VERTICES_PER_BORDER, TIME_UNIT_LENGTH, ROAD_WIDTH, ROAD_COLOR);
        lattice = new Lattice();
        obstaclesWorkshop = new ObstaclesWorkshop();
    }

    /**
     * Handles drawing of object specified by appropriate constants.
     *
     * @param mvpMatrix Matrix to apply to objects before rendering.
     *                  Usually camera's matrix.
     */
    public void render(float[] mvpMatrix) {
        if (itIsTimeForAnimation()) {
            switchFrame();
            animationCounter = 0;
        }
        if (LATTICE_RENDERING) {
            lattice.draw(mvpMatrix);
        }
        if (ROAD_RENDERING) {
            road.draw(mvpMatrix);
        }
        if(OBSTACLES_WORKSHOP_RENDERING) {
            obstaclesWorkshop.draw(mvpMatrix);
        }

        incrementAnimationCounter();
    }

    /**
     * Proceed with animation of objects with appropriate constants value.
     * See {@link #LATTICE_ANIMATION this constant} for example.
     */
    public void switchFrame() {
        tempCounter++;
        if (ROAD_ANIMATION) {
            road.switchFrame();
        }
        if (LATTICE_ANIMATION) {
            lattice.switchFrame();
        }
        if(OBSTACLES_WORKSHOP_ANIMATION) {
            obstaclesWorkshop.switchFrame();
        }
    }

    /**
     * Increments {@link #animationCounter animation counter} by 1.
     */
    public void incrementAnimationCounter() {
        animationCounter++;
    }

    /**
     * Checks frame switch condition and returns result.
     *
     * @return True or false, depending on the answer to the question:
     * "is {@link #animationCounter animation counter} the same as
     * {@link #ANIMATION_FREQUENCY animation frequency constant}".
     */
    private boolean itIsTimeForAnimation() {
        return (animationCounter == ANIMATION_FREQUENCY) ? true : false;
    }

}
